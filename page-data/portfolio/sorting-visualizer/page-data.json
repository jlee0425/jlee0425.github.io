{"componentChunkName":"component---src-templates-project-jsx","path":"/portfolio/sorting-visualizer","result":{"data":{"prismic":{"project":{"link":{"__typename":"PRISMIC__ExternalLink","url":"https://quirky-swirles-9080c2.netlify.app/"},"git":{"__typename":"PRISMIC__ExternalLink","url":"https://github.com/jlee0425/Sorting-Visualizer"},"date":[{"type":"heading6","text":"June 2020","spans":[]}],"body":[{"__typename":"PRISMIC_ProjectBodyText_with_title","primary":{"title1":[{"type":"heading2","text":"Why Sorting Visualizer?","spans":[]}],"body":[{"type":"paragraph","text":"During the curriculum, there were a few moments that I felt very impressed with coding.  Among other things, I was fascinated with sorting algorithms, especially how it's used in real-life cases such as a contact list to more complicated cases like sorting through a large and complex database.","spans":[]},{"type":"paragraph","text":"I thought of building a sorting visualizer back when I was learning the algorithms and databases in order to better understand the mechanisms and the step-by-step of each sorting process. Nevertheless, I didn't actually study GUI in C++ and the time passed.","spans":[]},{"type":"paragraph","text":"Studying Web development and React after graduation reminded me of the sorting algorithms that I learned in school, and finally, I decided to put together a visualizer app.","spans":[]}]}},{"__typename":"PRISMIC_ProjectBodyImage_text","primary":{"title1":[{"type":"heading1","text":"Writing algorithms and Testing","spans":[]}]},"fields":[{"img2":{"dimensions":{"width":408,"height":237},"alt":"Test results","copyright":null,"url":"https://images.prismic.io/jlee0425/69b8429c-9feb-43bd-b18d-7f47aeb008de_testResult.png?auto=compress,format"},"img1":{"dimensions":{"width":548,"height":400},"alt":"Testing method","copyright":null,"url":"https://images.prismic.io/jlee0425/4cf3d63c-6715-49d7-82ad-844e3711c2e5_testing.png?auto=compress,format"},"content":[{"type":"paragraph","text":"It has been over a year that I wrote sorting algorithms since the last time, and back then, I wrote the code in C++, not JavaScript. I was able to write the most of algorithms while recollecting what I learned, but I couldn't remember the core logic of Quick sort. For that I referenced a coding interview book that I have even though it was written in Python.","spans":[]},{"type":"paragraph","text":"To test algorithms, I generated a random array with range of -5 * size to 5 * size, sorted the array with a given algorithm and then compared the sorted array with a sorted array with built-in sorting algorithm. The testing is done from the size of 1 to 10,000.","spans":[]}]}]},{"__typename":"PRISMIC_ProjectBodyImage_text","primary":{"title1":[{"type":"heading1","text":"Animation","spans":[]}]},"fields":[{"img2":{"dimensions":{"width":441,"height":403},"alt":"Adding animations","copyright":null,"url":"https://images.prismic.io/jlee0425/2516ebb2-ddc3-41f8-a0d3-359624ff738a_animation.png?auto=compress,format"},"img1":{"dimensions":{"width":443,"height":269},"alt":"Running animations","copyright":null,"url":"https://images.prismic.io/jlee0425/7b1f9497-8023-469a-ae19-a85ee6341c90_swapping.png?auto=compress,format&rect=0,2,440,267&w=443&h=269"},"content":[{"type":"paragraph","text":"At the beginning of this project, I was more focused on implementing the algorithms and designing the looks of the app. I didn't think of how I would visualize each algorithm. It was after I finished the algorithm and the basic design that I realized that the actual hard part is the visualization of the sorting process.","spans":[]},{"type":"paragraph","text":"I decided to create an array named animations and a copy of the original array named temp, and then push each pair when they swap during the sorting process. After sorting is finished, I return an array of animations and since sorting was done on a copied array, the original array doesn't change whether the sorting is in-place or not. With the returned array of animations, I used react-spring useTransition to animate the sorting process","spans":[]},{"type":"paragraph","text":"Unlike other sorts, merge sort needs a new array during the process. For this one, I googled if there is a way to merge-sort in-place and studied the basic on GeeksforGeeks, then implemented my own version in JavaScript.","spans":[]}]}]},{"__typename":"PRISMIC_ProjectBodyText_with_title","primary":{"title1":[{"type":"heading2","text":"Redux vs. useContext","spans":[]}],"body":[{"type":"paragraph","text":"I started by setting up a store and dispatch functions on each toolbar that affects the array of the bars, such as the new button, sliders, and selecting an algorithm. However, it seemed a little bit too much to use an external library to simply update two elements in an array, and the selected algorithm, which is a string. So I googled redux replacements and found useContext hook.","spans":[]},{"type":"paragraph","text":"In this case, useContext hook seemed more suitable because this app is small, this app only re-renders on user interactions and state management can be done with a built-in hook without adding extra bundle size.","spans":[]}]}},{"__typename":"PRISMIC_ProjectBodyList","primary":{"list":[{"type":"list-item","text":"More information such as how each algorithm works, and respective time and space complexity.","spans":[]},{"type":"list-item","text":"A step-by-step function to clearly see which elements are being swapped at the moment.","spans":[]},{"type":"list-item","text":"More algorithms.","spans":[]}],"title1":[{"type":"heading2","text":"Possible enhancements","spans":[]}]}},{"__typename":"PRISMIC_ProjectBodyImage_text","primary":{"title1":[{"type":"heading1","text":"Known Issue","spans":[]}]},"fields":[{"img2":{"dimensions":{"width":870,"height":733},"alt":"Merge sort on Netlify","copyright":null,"url":"https://images.prismic.io/jlee0425/20d66380-21b1-47ab-ae33-160dece9e259_onNetlify.gif?auto=compress,format"},"img1":{"dimensions":{"width":817,"height":736},"alt":"Merge sort on localhost","copyright":null,"url":"https://images.prismic.io/jlee0425/ccb59e56-340b-419b-8fe8-4d80b3b96968_local.gif?auto=compress,format"},"content":[{"type":"paragraph","text":"Currently merge sort does not function as intended when deployed on Netlify.","spans":[]},{"type":"paragraph","text":"More specifically, merge sort produces multiple duplicates of same elements and it breaks the app due to elements with same key.","spans":[]},{"type":"paragraph","text":"What I have tried to fix: setting environmental variables on Netlify(fixed node version, fixed versions of each dependencies), modifying swap function, adding key comparison in swap function, memoizing the array and modifying the animation.","spans":[]},{"type":"paragraph","text":"I am working on a fix as I come up with a new idea as to what breaks the app when deployed.","spans":[]}]}]}],"preview":{"dimensions":{"width":809,"height":730},"alt":null,"copyright":null,"url":"https://images.prismic.io/jlee0425/32e5c3e6-6c7d-424b-be1c-2f33a9716bed_sorting-visualizer.png?auto=compress,format"},"summary":[{"type":"paragraph","text":"A single page web app that visualizes how sorting algorithms work. It contains 5 common sorting algorithms: bubble sort, insertion sort, heap sort, quick sort and merge sort. The app shows how the sorting algorithms work by animating the swapping.","spans":[]}],"title":[{"type":"heading1","text":"Sorting Visualizer","spans":[]}]}}},"pageContext":{"rootQuery":null,"id":"XzYg5hIAALhk_mi7","lang":"en-us","uid":"sorting-visualizer","type":"project","alternateLanguages":[],"cursor":"YXJyYXljb25uZWN0aW9uOjI=","paginationPreviousMeta":{"id":"XzYiFBIAALhk_m5I","lang":"en-us","uid":"portfolio","type":"project","alternateLanguages":[]},"paginationPreviousUid":"portfolio","paginationPreviousLang":"en-us","paginationNextMeta":{"id":"XzYh3RIAALhk_m1O","lang":"en-us","uid":"covid19-tracker","type":"project","alternateLanguages":[]},"paginationNextUid":"covid19-tracker","paginationNextLang":"en-us","lastQueryChunkEndCursor":""}},"staticQueryHashes":["3000541721","3000541721"]}